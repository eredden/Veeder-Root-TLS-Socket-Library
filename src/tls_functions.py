import math
from tls_socket import tlsSocket

def get_standard_values(output: str) -> dict:
    """
    Get standard values from a command response; date, time, checksum. Return as a dict.

    output - Output of a command sent to a TLS system as a string.
    """

    data = {}

    data["year"] = int(output[0:2])
    data["month"] = int(output[2:4])
    data["day"] = int(output[4:6])
    data["hour"] = int(output[6:8])
    data["minute"] = int(output[8:10])
    data["checksum"] = output[-4:]

    return data

def split_data(output: str, report_length: int) -> list:
    """
    Split apart repeating reports from a command response and return as a list.

    output - Output of a command sent to a TLS system as a string. This should only contain the repeating data.
    report_length - The expected length of each repeating report.
    """

    data = []

    for i, value in enumerate(output):
        array_position = math.floor(i / report_length)

        if i % report_length == 0: data.append(value)
        else: data[array_position] = data[array_position] + value
    
    return data

def hex_to_float(hex: str) -> float:
    """
    Convert hexadecimal codes generated by the command responses into IEEE floats.

    hex - An 8 character hexidecimal code stored as a string.
    """

    binary = ""

    for char in hex:
        hex_int = int(char, 16)
        hex_bin = format(hex_int, "04b")
        binary = binary + str(hex_bin)

    negative_int = int(binary[0], 2)
    negative = bool(negative_int)

    exponent_int = int(binary[1:9], 2)
    exponent = 2 ** (exponent_int - 127)

    mantissa_int = int(binary[9:], 2)
    mantissa_field = 2 ** 23
    mantissa = 1.0 + (mantissa_int / mantissa_field)

    if negative: exponent = -abs(exponent)

    decimal = round(exponent * mantissa, 5)

    return decimal

def function_101(tls: tlsSocket, tank: str, timeout: int) -> dict:
    """
    Runs function 101 on a given Veeder-Root TLS device and returns a dict with report info.

    tls - A socket for a TLS device, should be created with the tlsSocket class.
    tank - The tank number (ex. 00 for all tanks, 01 for tank one, etc).
    timeout - Time to wait for a response from the socket after executing the command.
    """

    command = "i101" + tank
    response = tls.execute(command, timeout)

    # verify that data came through completely
    data_termination_flag = response[-6:-4]
    if data_termination_flag != "&&":
        return "Checksum missing from command response, transmission either partially completed or failed."
    
    data = get_standard_values(response)

    # strip generic values from data, then split into individual chunks
    remaining_data = response[10:-6]
    expected_data_length = 6
    split_remaining_data = split_data(remaining_data, expected_data_length)
    
    data["alarms"] = {}
    alarms = data["alarms"]

    if len(remaining_data) < expected_data_length:
        return data

    # split values from within each individual tank report
    for i, value in enumerate(split_remaining_data):
        alarm_number = str(i + 1)
        alarms["alarm_" + alarm_number] = {}

        alarm_data = alarms["alarm_" + alarm_number]
        alarm_data["alarm_category"] = int(value[0:2])
        alarm_data["alarm_type"] = int(value[2:4])
        alarm_data["tank_number"] = int(value[4:6])

    return data
        
def function_102(tls: tlsSocket, timeout: int) -> dict:
    """
    Runs function 102 on a given Veeder-Root TLS device and returns a dict with report info.

    tls - A socket for a TLS device, should be created with the tlsSocket class.
    timeout - Time to wait for a response from the socket after executing the command.
    """

    command = "i10200"
    response = tls.execute(command, timeout)

    # verify that data came through completely
    data_termination_flag = response[-6:-4]
    if data_termination_flag != "&&":
        return "Checksum missing from command response, transmission either partially completed or failed."
    
    data = get_standard_values(response)

    # strip generic values from data, then split into individual chunks
    remaining_data = response[12:-6]
    expected_data_length = 20
    split_remaining_data = split_data(remaining_data, expected_data_length)

    data["slots"] = {}
    slots = data["slots"]

    if len(remaining_data) < expected_data_length:
        return data

    # split values from within each individual tank report
    for i, value in enumerate(split_remaining_data):
        slot_number = str(i + 1)
        slots["slot_" + slot_number] = {}
    
        slot_data = slots["slot_" + slot_number]
        slot_data["type_of_module"] = value[2:4]
        slot_data["power_on_reset"] = hex_to_float(value[4:12])
        slot_data["current_io_reading"] = hex_to_float(value[12:19])

    return data

def function_111(tls: tlsSocket, timeout: int) -> dict:
    """
    Runs function 111 on a given Veeder-Root TLS device and returns a dict with report info.

    tls - A socket for a TLS device, should be created with the tlsSocket class.
    timeout - Time to wait for a response from the socket after executing the command.
    """

    command = "i11100"
    response = tls.execute(command, timeout)

    # verify that data came through completely
    data_termination_flag = response[-6:-4]
    if data_termination_flag != "&&":
        return "Checksum missing from command response, transmission either partially completed or failed."
    
    data = get_standard_values(response)

    # strip generic values from data, then split into individual chunks
    remaining_data = response[10:-6]
    expected_data_length = 20
    split_remaining_data = split_data(remaining_data, expected_data_length)

    data["alarms"] = {}
    alarms = data["alarms"]

    if len(remaining_data) < expected_data_length:
        return data

    # split values from within each individual tank report
    for i, value in enumerate(split_remaining_data):
        alarm_number = str(i + 1)
        alarms["alarm_" + alarm_number] = {}
    
        alarm_data = alarms["alarm_" + alarm_number]
        alarm_data["alarm_category"] = int(value[0:2])
        alarm_data["sensor_category"] = int(value[2:4])
        alarm_data["alarm_type"] = int(value[4:6])
        alarm_data["tank_number"] = int(value[6:8])
        alarm_data["alarm_state"] = int(value[8:10])
        alarm_data["year"] = int(value[10:12])
        alarm_data["month"] = int(value[12:14])
        alarm_data["day"] = int(value[14:16])
        alarm_data["hour"] = int(value[16:18])
        alarm_data["minute"] = int(value[18:20])

    return data

def function_112(tls: tlsSocket, timeout: int) -> dict:
    """
    Runs function 112 on a given Veeder-Root TLS device and returns a dict with report info.

    tls - A socket for a TLS device, should be created with the tlsSocket class.
    timeout - Time to wait for a response from the socket after executing the command.
    """

    command = "i11200"
    response = tls.execute(command, timeout)

    # verify that data came through completely
    data_termination_flag = response[-6:-4]
    if data_termination_flag != "&&":
        return "Checksum missing from command response, transmission either partially completed or failed."
    
    data = get_standard_values(response)

    # strip generic values from data, then split into individual chunks
    remaining_data = response[10:-6]
    expected_data_length = 20
    split_remaining_data = split_data(remaining_data, expected_data_length)

    data["alarms"] = {}
    alarms = data["alarms"]

    if len(remaining_data) < expected_data_length:
        return data

    # split values from within each individual tank report
    for i, value in enumerate(split_remaining_data):
        alarm_number = str(i + 1)
        alarms["alarm_" + alarm_number] = {}
    
        alarm_data = alarms["alarm_" + alarm_number]
        alarm_data["alarm_category"] = int(value[0:2])
        alarm_data["sensor_category"] = int(value[2:4])
        alarm_data["alarm_type"] = int(value[4:6])
        alarm_data["tank_number"] = int(value[6:8])
        alarm_data["alarm_state"] = int(value[8:10])
        alarm_data["year"] = int(value[10:12])
        alarm_data["month"] = int(value[12:14])
        alarm_data["day"] = int(value[14:16])
        alarm_data["hour"] = int(value[16:18])
        alarm_data["minute"] = int(value[18:20])

    return data

def function_113(tls: tlsSocket, timeout: int) -> dict:
    """
    Runs function 113 on a given Veeder-Root TLS device and returns a dict with report info.

    tls - A socket for a TLS device, should be created with the tlsSocket class.
    timeout - Time to wait for a response from the socket after executing the command.
    """

    command = "i11300"
    response = tls.execute(command, timeout)

    # verify that data came through completely
    data_termination_flag = response[-6:-4]
    if data_termination_flag != "&&":
        return "Checksum missing from command response, transmission either partially completed or failed."
    
    data = get_standard_values(response)

    # store extra non-repeated info from this response
    data["station_header_1"] = response[10:30].strip()
    data["station_header_2"] = response[30:50].strip()
    data["station_header_3"] = response[50:70].strip()
    data["station_header_4"] = response[70:90].strip()

    # strip generic values from data, then split into individual chunks
    remaining_data = response[90:-6]
    expected_data_length = 18
    split_remaining_data = split_data(remaining_data, expected_data_length)

    data["alarms"] = {}
    alarms = data["alarms"]

    if len(remaining_data) < expected_data_length:
        return data

    # split values from within each individual tank report
    for i, value in enumerate(split_remaining_data):
        alarm_number = str(i + 1)
        alarms["alarm_" + alarm_number] = {}
    
        alarm_data = alarms["alarm_" + alarm_number]
        alarm_data["alarm_category"] = int(value[0:2])
        alarm_data["sensor_category"] = int(value[2:4])
        alarm_data["alarm_type"] = int(value[4:6])
        alarm_data["tank_number"] = int(value[6:8])
        alarm_data["year"] = int(value[8:10])
        alarm_data["month"] = int(value[10:12])
        alarm_data["day"] = int(value[12:14])
        alarm_data["hour"] = int(value[14:16])
        alarm_data["minute"] = int(value[16:18])

    return data

def function_114(tls: tlsSocket, timeout: int) -> dict:
    """
    Runs function 114 on a given Veeder-Root TLS device and returns a dict with report info.

    tls - A socket for a TLS device, should be created with the tlsSocket class.
    timeout - Time to wait for a response from the socket after executing the command.
    """

    command = "i11400"
    response = tls.execute(command, timeout)

    # verify that data came through completely
    data_termination_flag = response[-6:-4]
    if data_termination_flag != "&&":
        return "Checksum missing from command response, transmission either partially completed or failed."
    
    data = get_standard_values(response)

    # store extra non-repeated info from this response
    data["station_header_1"] = response[10:30].strip()
    data["station_header_2"] = response[30:50].strip()
    data["station_header_3"] = response[50:70].strip()
    data["station_header_4"] = response[70:90].strip()

    # strip generic values from data, then split into individual chunks
    remaining_data = response[90:-6]
    expected_data_length = 20
    split_remaining_data = split_data(remaining_data, expected_data_length)

    data["alarms"] = {}
    alarms = data["alarms"]

    if len(remaining_data) < expected_data_length:
        return data

    # split values from within each individual tank report
    for i, value in enumerate(split_remaining_data):
        alarm_number = str(i + 1)
        alarms["alarm_" + alarm_number] = {}
    
        alarm_data = alarms["alarm_" + alarm_number]
        alarm_data["alarm_category"] = int(value[0:2])
        alarm_data["sensor_category"] = int(value[2:4])
        alarm_data["alarm_type"] = int(value[4:6])
        alarm_data["tank_number"] = int(value[6:8])
        alarm_data["alarm_state"] = int(value[8:10])
        alarm_data["year"] = int(value[10:12])
        alarm_data["month"] = int(value[12:14])
        alarm_data["day"] = int(value[14:16])
        alarm_data["hour"] = int(value[16:18])
        alarm_data["minute"] = int(value[18:20])

    return data

def function_115(tls: tlsSocket, timeout: int) -> dict:
    """
    Runs function 115 on a given Veeder-Root TLS device and returns a dict with report info.

    tls - A socket for a TLS device, should be created with the tlsSocket class.
    timeout - Time to wait for a response from the socket after executing the command.
    """

    command = "i11500"
    response = tls.execute(command, timeout)

    # verify that data came through completely
    data_termination_flag = response[-6:-4]
    if data_termination_flag != "&&":
        return "Checksum missing from command response, transmission either partially completed or failed."
    
    data = get_standard_values(response)

    # store extra non-repeated info from this response
    data["station_header_1"] = response[10:30].strip()
    data["station_header_2"] = response[30:50].strip()
    data["station_header_3"] = response[50:70].strip()
    data["station_header_4"] = response[70:90].strip()

    # strip generic values from data, then split into individual chunks
    remaining_data = response[90:-6]
    expected_data_length = 18
    split_remaining_data = split_data(remaining_data, expected_data_length)

    data["alarms"] = {}
    alarms = data["alarms"]

    if len(remaining_data) < expected_data_length:
        return data

    # split values from within each individual tank report
    for i, value in enumerate(split_remaining_data):
        alarm_number = str(i + 1)
        alarms["alarm_" + alarm_number] = {}
    
        alarm_data = alarms["alarm_" + alarm_number]
        alarm_data["alarm_category"] = int(value[0:2])
        alarm_data["sensor_category"] = int(value[2:4])
        alarm_data["alarm_type"] = int(value[4:6])
        alarm_data["tank_number"] = int(value[6:8])
        alarm_data["year"] = int(value[8:10])
        alarm_data["month"] = int(value[10:12])
        alarm_data["day"] = int(value[12:14])
        alarm_data["hour"] = int(value[14:16])
        alarm_data["minute"] = int(value[16:18])

    return data

def function_201(tls: tlsSocket, tank: str, timeout: int) -> dict:
    """
    Runs function 201 on a given Veeder-Root TLS device and returns a dict with report info.

    tls - A socket for a TLS device, should be created with the tlsSocket class.
    tank - The tank number (ex. 00 for all tanks, 01 for tank one, etc).
    timeout - Time to wait for a response from the socket after executing the command.
    """

    command = "i201" + tank
    response = tls.execute(command, timeout)

    # verify that data came through completely
    data_termination_flag = response[-6:-4]
    if data_termination_flag != "&&":
        return "Checksum missing from command response, transmission either partially completed or failed."
    
    data = get_standard_values(response)

    # strip generic values from data, then split into individual chunks
    remaining_data = response[10:-6]
    expected_data_length = 65
    split_remaining_data = split_data(remaining_data, expected_data_length)

    if len(remaining_data) < expected_data_length:
        return data

    # split values from within each individual tank report
    for value in split_remaining_data:
        tank_number = value[0:2]
        data["tank_" + tank_number] = {}
    
        tank_data = data["tank_" + tank_number]
        tank_data["product_code"] = value[2:3]
        tank_data["tank_status_bits"] = int(value[3:7])
        tank_data["volume"] = hex_to_float(value[9:17])
        tank_data["tc_volume"] = hex_to_float(value[17:25])
        tank_data["ullage"] = hex_to_float(value[25:33])
        tank_data["height"] = hex_to_float(value[33:41])
        tank_data["water"] = hex_to_float(value[41:49])
        tank_data["temperature"] = hex_to_float(value[49:57])
        tank_data["water_volume"] = hex_to_float(value[57:65])

    return data
