import socket
import time

class tlsSocket:
    """
    Defines a socket for the TLS-3XX and TLS-4XX systems manufactured by Veeder-Root.

    execute() - Used to send a command and view the output in accordance with Veeder-Root Serial Interface Manual 576013-635.
    """

    def __init__(self, ip: str, port: int):
        self.ip = ip
        self.port = port

        socket_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        try:
            socket_connection.connect((self.ip, self.port))
            self.socket = socket_connection
        
        except Exception as exception:
            raise exception
        
    def __str__(self):
        return f"tlsSocket({self.ip}, {self.port}, {self.socket})"

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        socket = self.socket
        socket.close()

    def execute(self, command: str, timeout: int) -> bytes:
        """
        Sends a command to a socket connection using the command format from the Veeder-Root Serial Interface Manual 576013-635.

        command - The function code you would like to execute. Make sure this is in computer format. \n
        timeout - The amount of time to wait for a response from the host. Adjust this as needed.
        """

        socket = self.socket
        start_of_header = b"\x01"
        invalid_command_error = b"FF1B"
        
        command = start_of_header + bytes(command, "utf-8")

        socket.sendall(command)
        time.sleep(timeout)
        response = socket.recv(512)

        if invalid_command_error in response:
            response = b"Unrecognized function code. Use the command format form of the function."
            print(response)
            return response

        return response

def tls_parser(response: bytes, command: str) -> str:
    """
    Takes output from any command and removes the SOH, originally sent command, and ETX.

    response - Response/output from a command ran with execute() from the tlsSocket class.
    command - The command used to get this output.
    """

    response = response.decode("utf-8")
    
    # Removes SOH, ETX, and command from being shown in output.
    # This applies to both Computer and Display format commands.
    response = response[1:]
    response = response[:-1]
    response = response.replace(command, "")

    # Checks for and removes newlines at both ends of output, removes if present.
    # Only applies to Display format commands.
    if response[:2] == "\r\n":
        response = response[2:]

    if response[-4:] == "\r\n\r\n":
        response = response[:-4]

    return response

def get_standard_values(output: str) -> dict:
    """
    Get standard values from a command response; date, time, checksum.

    output - Output of a command sent to a TLS system as a string.
    """

    data = {}

    data["year"] = int(output[0:2])
    data["month"] = int(output[2:4])
    data["day"] = int(output[4:6])
    data["hour"] = int(output[6:8])
    data["minute"] = int(output[8:10])
    data["checksum"] = output[-4:]

    return data

def hex_to_float(hex: str) -> float:
    """
    Convert hexadecimal codes generated by the command responses into IEEE floats.

    hex - An 8 character hexidecimal code stored as a string.
    """

    binary = ""

    for char in hex:
        hex_int = int(char, 16)
        hex_bin = format(hex_int, "04b")
        binary = binary + str(hex_bin)

    negative_int = int(binary[0], 2)
    negative = bool(negative_int)

    exponent_int = int(binary[1:9], 2)
    exponent = 2 ** (exponent_int - 127)

    mantissa_int = int(binary[9:], 2)
    mantissa_field = 2 ** 23
    mantissa = 1.0 + (mantissa_int / mantissa_field)

    if negative: exponent = -abs(exponent)

    decimal = round(exponent * mantissa, 5)

    return decimal
